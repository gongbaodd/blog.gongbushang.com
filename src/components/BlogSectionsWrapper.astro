---
import BlogSections from "./BlogSections";
import dayjs from "dayjs";
import { getAllPostByDateDesc, initYearMonthPostMap } from "@/packages/utils/filter";
import { date } from "@/packages/utils/extract";
import { mapServerPostToClient } from "@/packages/utils/post";
import { getCounts } from "@/packages/utils/heatmap";
import type { CollectionEntry } from "astro:content";
import { FILTER_ENTRY } from "@/packages/consts";
type T_POST = CollectionEntry<"blog">

const _posts = await getAllPostByDateDesc();
const latestPosts = await mapServerPostToClient(_posts.slice(0, 5));

const buildYear = dayjs().format("YYYY");
const buildMonth = dayjs().format("MM");
const buildDay = dayjs().format("DD");
const monthPostMap = initYearMonthPostMap(_posts);

const sameMonthPosts: (T_POST)[] = [];

for (const [yearMonth, postsSet] of monthPostMap) {
  const [_year, month] = yearMonth.split("-");

  if (_year === buildYear) continue;
  
  if (month === buildMonth) {
    sameMonthPosts.push(...Array.from(postsSet));
  }
}

const postsWithDayProximity = sameMonthPosts.map(post => {
  const postDate = dayjs(date(post));
  const postDay = postDate.format("DD");
  const dayDiff = Math.abs(parseInt(postDay) - parseInt(buildDay));
  
  return {
    post,
    dayDiff,
    postDay: parseInt(postDay)
  };
});

const sortedByDayProximity = postsWithDayProximity.sort((a, b) => {
  if (a.dayDiff !== b.dayDiff) {
    return a.dayDiff - b.dayDiff; 
  }
  return a.postDay - b.postDay;
});

const selectedMonthPosts = sortedByDayProximity.slice(0, 5).map(item => item.post)
const historyPosts = (await mapServerPostToClient(selectedMonthPosts)).sort((a, b) => {
  if (a.data.cover) return -1
  if (b.data.cover) return 1
  return  Number(a.date) - Number(b.date)
})

const counts = await getCounts()
---

<BlogSections
  latestPosts={latestPosts}
  historyPosts={historyPosts}
  totalCount={counts[FILTER_ENTRY.ALL]}
  client:load
/>